<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="测试计划">
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="用户定义的变量">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
    </TestPlan>
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="方案">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">20</intProp>
        <longProp name="ThreadGroup.delay">0</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="循环控制器">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="查看结果树">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="聚合报告" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="SummaryReport" testclass="ResultCollector" testname="汇总报告" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
          <collectionProp name="Arguments.arguments">
            <elementProp name="V_SCHEME" elementType="Argument">
              <stringProp name="Argument.name">V_SCHEME</stringProp>
              <stringProp name="Argument.value">https</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="V_HOST" elementType="Argument">
              <stringProp name="Argument.name">V_HOST</stringProp>
              <stringProp name="Argument.value">gwapp-test.hugofayu.com</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="currentTime" elementType="Argument">
              <stringProp name="Argument.name">currentTime</stringProp>
              <stringProp name="Argument.value">${__time(yyyy-MM-dd HH:mm:ss)}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Content-Type" elementType="Argument">
              <stringProp name="Argument.name">Content-Type</stringProp>
              <stringProp name="Argument.value">application/json</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="X-Tenant-Id" elementType="Argument">
              <stringProp name="Argument.name">X-Tenant-Id</stringProp>
              <stringProp name="Argument.value">1000000000000000000</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="X-Trace-Id" elementType="Argument">
              <stringProp name="Argument.name">X-Trace-Id</stringProp>
              <stringProp name="Argument.value">61266561-55A8-40BF-9A13-7F380B7CE71C</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="User-Agent" elementType="Argument">
              <stringProp name="Argument.name">User-Agent</stringProp>
              <stringProp name="Argument.value">NewsPort/1.0.0 (com.dz.sports; build:1; iOS 13.5.1) Alamofire/5.10.2</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="X-Device-Id" elementType="Argument">
              <stringProp name="Argument.name">X-Device-Id</stringProp>
              <stringProp name="Argument.value">91E047FF-BBB0-4D97-948C-2B432DEC24F1</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="X-App-Version" elementType="Argument">
              <stringProp name="Argument.name">X-App-Version</stringProp>
              <stringProp name="Argument.value">1.0.0</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="PrivateKey" elementType="Argument">
              <stringProp name="Argument.name">PrivateKey</stringProp>
              <stringProp name="Argument.value">MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAKVdJA6T3tTILyWJVbZOGoPpVhRychjqAf7Yyin0Yh7EhJOZ+6ir5XetnhuLBd9yFGgWSTPeoZ7r4Yzs66mVHsQyVobtz/m0mSUznGbNee+DVXKQMBBgTnuqt9rZTGweyqiqOTCWSYlyx1M83hctu3hbmnJoExhZy3qe76B7thG/AgMBAAECgYAT+zgzJr0DOxkvUPPxbmiXzecf22BcEFKjZ7Ct9yCwFRDsAOw+yl6U4n67V0YjZNaAaUj5Ioqm+FutuqcTO7iWy77WSjs8fEhNtledrDRVqYPA5kj9Gu4aV7rZqWNI+HQQkwXH2Rx9FaeLcKCQmbymr/jh7N0I+I0AAwNRRvjZCQJBAPuV/pCvmyGD4gv8YljIohiQdGpFpSHapR+JBCRc5ZH7ug8Ij26DQzUZvnBQqFYy0dCqLSyVRb5wLoBMTlc6jq0CQQCoQ+CdeR33wdNg3brR7KCZoXOf01tftegBfqRl1RpDEY7JBMP5snvVwfoK6WWWKOpo8bI3Skxdax6aNvNI6UubAkAGUZgZLi/pQZS11Frr++4GS+qAmMsy9HjdN+XAvAyQBBCCPCbOEcHoXYMo8v2nXJNkeEG2MvGTfOHOGxyEmFXpAkEApHhshiAMDc9USPuSj3zm4iQw+4lBaEVLOKLMGIl7ORFhatWQpXIznxYSzTWjyWnG7rtJAshJ6oo5CG4r0RnQfwJAQzxUk57x4wnsiMsNV7KkCx2431ESYqjfBkXdjvNh7y1+W2FHrGa2MpHEC/oztx+e1tKesWM53fSFzLY+cZWh8w==</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="publicKey" elementType="Argument">
              <stringProp name="Argument.name">publicKey</stringProp>
              <stringProp name="Argument.value">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQClXSQOk97UyC8liVW2ThqD6VYUcnIY6gH+2Mop9GIexISTmfuoq+V3rZ4biwXfchRoFkkz3qGe6+GM7OuplR7EMlaG7c/5tJklM5xmzXnvg1VykDAQYE57qrfa2UxsHsqoqjkwlkmJcsdTPN4XLbt4W5pyaBMYWct6nu+ge7YRvwIDAQAB</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="salt" elementType="Argument">
              <stringProp name="Argument.name">salt</stringProp>
              <stringProp name="Argument.value">MmqrvUFwNStQ2xrhp8a7bA==</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="userId" elementType="Argument">
              <stringProp name="Argument.name">userId</stringProp>
              <stringProp name="Argument.value">${__P(userId)}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="planDetailIds" elementType="Argument">
              <stringProp name="Argument.name">planDetailIds</stringProp>
              <stringProp name="Argument.value">1001,1004,3001</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP Request Defaults">
          <stringProp name="HTTPSampler.domain">${V_HOST}</stringProp>
          <stringProp name="HTTPSampler.protocol">${V_SCHEME}</stringProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
          <stringProp name="HTTPSampler.implementation"></stringProp>
        </ConfigTestElement>
        <hashTree/>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager">
          <collectionProp name="HeaderManager.headers">
            <elementProp name="X-Tenant-Id" elementType="Header">
              <stringProp name="Header.name">X-Tenant-Id</stringProp>
              <stringProp name="Header.value">${X-Tenant-Id}</stringProp>
            </elementProp>
            <elementProp name="X-Sign" elementType="Header">
              <stringProp name="Header.name">X-Sign</stringProp>
              <stringProp name="Header.value">${X-Sign}</stringProp>
            </elementProp>
            <elementProp name="X-Token" elementType="Header">
              <stringProp name="Header.name">X-Token</stringProp>
              <stringProp name="Header.value">${X-Token}</stringProp>
            </elementProp>
            <elementProp name="User-Agent" elementType="Header">
              <stringProp name="Header.name">User-Agent</stringProp>
              <stringProp name="Header.value">${User-Agent}</stringProp>
            </elementProp>
            <elementProp name="X-Device-Id" elementType="Header">
              <stringProp name="Header.name">X-Device-Id</stringProp>
              <stringProp name="Header.value">${X-Device-Id}</stringProp>
            </elementProp>
            <elementProp name="X-App-Version" elementType="Header">
              <stringProp name="Header.name">X-App-Version</stringProp>
              <stringProp name="Header.value">${X-App-Version}</stringProp>
            </elementProp>
            <elementProp name="Content-Type" elementType="Header">
              <stringProp name="Header.name">Content-Type</stringProp>
              <stringProp name="Header.value">${Content-Type}</stringProp>
            </elementProp>
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">X-Trace-Id</stringProp>
              <stringProp name="Header.value">${X-Trace-Id}</stringProp>
            </elementProp>
          </collectionProp>
        </HeaderManager>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV 数据文件设置" enabled="false">
          <stringProp name="delimiter">,</stringProp>
          <stringProp name="fileEncoding">UTF-8</stringProp>
          <stringProp name="filename">C:/kst/jm/plan.csv</stringProp>
          <boolProp name="ignoreFirstLine">true</boolProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
          <boolProp name="stopThread">true</boolProp>
          <stringProp name="variableNames">phone,isFree,Price </stringProp>
        </CSVDataSet>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV 数据文件设置-ljks">
          <stringProp name="delimiter">,</stringProp>
          <stringProp name="fileEncoding">UTF-8</stringProp>
          <stringProp name="filename">plan-test.csv</stringProp>
          <boolProp name="ignoreFirstLine">true</boolProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
          <boolProp name="stopThread">true</boolProp>
          <stringProp name="variableNames">phone,isFree,Price </stringProp>
        </CSVDataSet>
        <hashTree/>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="简单控制器"/>
        <hashTree>
          <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="密码加密" enabled="true">
            <stringProp name="TestPlan.comments">采用的是RSA加密，Base64编码</stringProp>
            <stringProp name="BeanShellSampler.query">import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;
import javax.crypto.Cipher;
import java.util.Base64;

// 公钥字符串(需要替换为实际的公钥)
String publicKeyPEM = &quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCeFyVkUDrMAbn0WhDzI1IA+/z0m1k286A3AgzckLT0JKRFXvykkfQEYcymS4ncuCq/Im+CHVCs5L1ZU/hPoXvNhfwMEiXWx4PG1JUOrufl5cueizrsxIMJvQQki058wDyxEm0p6d8v9lFw5IAlTA5pQS6mZEhdPPdxVGABS1e0JQIDAQAB&quot;;

// 去除公钥字符串的头尾，转换为字节数组
String publicKeyStr = publicKeyPEM.replace(&quot;-----BEGIN PUBLIC KEY-----&quot;, &quot;&quot;)
                                  .replace(&quot;-----END PUBLIC KEY-----&quot;, &quot;&quot;)
                                  .replaceAll(&quot;\\s&quot;, &quot;&quot;);
byte[] encodedKey = Base64.getDecoder().decode(publicKeyStr);

// 解析公钥
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);
X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encodedKey);
PublicKey publicKey = keyFactory.generatePublic(keySpec);

// 待加密的密码，替换为实际的密码
String password = &quot;Aa11@@&quot;;
byte[] passwordBytes = password.getBytes(&quot;UTF-8&quot;);

// 使用公钥加密密码
Cipher cipher = Cipher.getInstance(&quot;RSA&quot;);
cipher.init(Cipher.ENCRYPT_MODE, publicKey);
byte[] encryptedPassword = cipher.doFinal(passwordBytes);

// 加密密码转化为Base64编码字符串
String encryptedPasswordBase64 = Base64.getEncoder().encodeToString(encryptedPassword);

// 加密后的密码设置变量，后续调用
vars.put(&quot;encryptedPassword&quot;, encryptedPasswordBase64);
</stringProp>
          </BeanShellSampler>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="login" enabled="true">
            <stringProp name="HTTPSampler.path">/api/c/user/login/by/account</stringProp>
            <boolProp name="HTTPSampler.auto_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&quot;phone&quot;:&quot;${phone}&quot;,&quot;zone&quot;:&quot;86&quot;,&quot;password&quot;:&quot;${encryptedPassword}&quot;}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager-login" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="X-Sign" elementType="Header">
                  <stringProp name="Header.name">X-Sign</stringProp>
                  <stringProp name="Header.value"></stringProp>
                </elementProp>
                <elementProp name="X-Token" elementType="Header">
                  <stringProp name="Header.name">X-Token</stringProp>
                  <stringProp name="Header.value"></stringProp>
                </elementProp>
                <elementProp name="X-Timestamp" elementType="Header">
                  <stringProp name="Header.name">X-Timestamp</stringProp>
                  <stringProp name="Header.value">${__time(,)}</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="-266464859">userType</stringProp>
              </collectionProp>
              <stringProp name="Assertion.custom_message"></stringProp>
              <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
              <boolProp name="Assertion.assume_success">false</boolProp>
              <intProp name="Assertion.test_type">2</intProp>
            </ResponseAssertion>
            <hashTree/>
            <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON提取器" enabled="true">
              <stringProp name="JSONPostProcessor.referenceNames">extracted_token</stringProp>
              <stringProp name="JSONPostProcessor.jsonPathExprs">$.data.token</stringProp>
              <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
            </JSONPostProcessor>
            <hashTree/>
            <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="JSR223 后置处理程序" enabled="true">
              <stringProp name="scriptLanguage">groovy</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="script">// 获取响应中的token（假设使用正则表达式提取器提取）
def token = vars.get(&quot;extracted_token&quot;)
// 生成 token 并保存为线程变量
//vars.put(&quot;token_&quot; + ctx.getThreadNum(), token)
vars.put(&quot;X-Token&quot;, token)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;token_&quot; + ctx.getThreadNum(), token)
//vars.put(&quot;token_&quot; + threadNum, token);</stringProp>
            </JSR223PostProcessor>
            <hashTree/>
          </hashTree>
          <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler-sign" enabled="false">
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">import java.security.KeyFactory
import java.security.PrivateKey
import java.security.Signature
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Base64
import java.util.TreeMap
import java.util.stream.Collectors

// 定义常量
def talentId = vars.get(&quot;X-Tenant-Id&quot;)
def timestamp = vars.get(&quot;X-Timestamp&quot;)
def deviceId = vars.get(&quot;X-Device-Id&quot;)
def token = System.currentTimeMillis()
//def token = vars.get(&quot;token_&quot; + ctx.getThreadNum()) // 使用 ctx.getThreadNum() 获取线程编号
def appVersion = vars.get(&quot;X-App-Version&quot;)
def traceId = vars.get(&quot;X-Trace-Id&quot;)
def salt = vars.get(&quot;salt&quot;)

// 创建 TreeMap 并添加参数
def headers = new TreeMap&lt;String, String&gt;()
headers.put(&quot;X-Tenant-Id&quot;, talentId)
headers.put(&quot;X-Timestamp&quot;, timestamp)
headers.put(&quot;X-Device-Id&quot;, deviceId)
headers.put(&quot;X-Token&quot;, token)
headers.put(&quot;X-App-Version&quot;, appVersion)
headers.put(&quot;X-Trace-Id&quot;, traceId)

// 生成数据字符串
def data = headers.entrySet()
    .stream()
    .map { entry -&gt; entry.getKey() + &quot;=&quot; + entry.getValue() }
    .collect(Collectors.joining(&quot;&amp;&quot;))

// 签名生成方法
def sign(String data, String salt, PrivateKey key) {
    def signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initSign(key)
    data = data + salt
    signature.update(data.getBytes())
    return new String(Base64.getEncoder().encode(signature.sign()))
}

// Base64 编码的私钥字符串
String base64PrivateKey = &quot;${PrivateKey}&quot;

// 解码 Base64 字符串为字节数组
byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey)

// 使用 KeyFactory 生成 PrivateKey 对象
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
PrivateKey key = keyFactory.generatePrivate(keySpec)

// 生成签名
def signature = sign(data, salt, key)

// 将签名存储到 JMeter 变量中
vars.put(&quot;srcData&quot;, data)
vars.put(&quot;X-Sign&quot;, signature)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;sign_&quot; + ctx.getThreadNum(), signature)

// 设置全局变量（如果需要）
//props.put(&quot;X-Sign&quot;, signature)
</stringProp>
            <stringProp name="scriptLanguage">groovy</stringProp>
          </JSR223Sampler>
          <hashTree>
            <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="调试后置处理程序" enabled="true">
              <boolProp name="displayJMeterProperties">false</boolProp>
              <boolProp name="displayJMeterVariables">true</boolProp>
              <boolProp name="displaySamplerProperties">true</boolProp>
              <boolProp name="displaySystemProperties">false</boolProp>
            </DebugPostProcessor>
            <hashTree/>
            <JSR223Assertion guiclass="TestBeanGUI" testclass="JSR223Assertion" testname="JSR223 断言" enabled="true">
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.security.KeyFactory
import java.security.PublicKey
import java.security.Signature
import java.security.spec.X509EncodedKeySpec
import java.util.Base64

// 验证签名的方法
def verify(String srcData, String salt, String sign, PublicKey publicKey) throws Exception {
    if (srcData == null || salt == null || sign == null || publicKey == null) {
        throw new IllegalArgumentException(&quot;输入参数不能为null&quot;)
    }
    Signature signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initVerify(publicKey)
    srcData = srcData + salt
    signature.update(srcData.getBytes())
    return signature.verify(Base64.getDecoder().decode(sign.getBytes()))
}

// 示例数据
def srcData = vars.get(&quot;srcData&quot;) // 从 JMeter 变量中获取数据
def salt = vars.get(&quot;salt&quot;) // 从 JMeter 变量中获取盐值
def sign = vars.get(&quot;X-Sign&quot;)
//def sign = vars.get(&quot;sign_&quot; + ctx.getThreadNum()) // 从 JMeter 变量中获取签名
def base64PublicKey = vars.get(&quot;publicKey&quot;) // 从 JMeter 变量中获取 Base64 编码的公钥字符串

if (srcData == null || salt == null || sign == null || base64PublicKey == null) {
    SampleResult.setSuccessful(false)
    SampleResult.setResponseMessage(&quot;输入参数不能为null&quot;)
    SampleResult.setResponseCode(&quot;500&quot;)
} else {
    // 解码 Base64 编码的公钥字符串
    byte[] publicKeyBytes = Base64.getDecoder().decode(base64PublicKey)
    X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKeyBytes)
    KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
    PublicKey publicKey = keyFactory.generatePublic(keySpec)

    // 验证签名
    def isValid = verify(srcData, salt, sign, publicKey)
    log.info(&quot;签名验证结果: &quot; + isValid)

    // 断言签名是否有效
    if (!isValid) {
        SampleResult.setSuccessful(false)
        SampleResult.setResponseMessage(&quot;签名验证失败&quot;)
        SampleResult.setResponseCode(&quot;500&quot;)
    } else {
        SampleResult.setSuccessful(true)
        SampleResult.setResponseMessage(&quot;签名验证成功&quot;)
        SampleResult.setResponseCode(&quot;200&quot;)
    }
}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Assertion>
            <hashTree/>
          </hashTree>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="infox" enabled="false">
          <stringProp name="TestPlan.comments">Created from cURL on 2025-01-23T23:09:55.2022831</stringProp>
          <stringProp name="HTTPSampler.path">/api/c/user/info</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 预处理程序" enabled="true">
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">import java.security.KeyFactory
import java.security.PrivateKey
import java.security.Signature
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Base64
import java.util.TreeMap
import java.util.stream.Collectors

// 定义常量
def talentId = vars.get(&quot;X-Tenant-Id&quot;)
def timestamp = System.currentTimeMillis().toString()
//def timestamp = vars.get(&quot;login-Timestamp&quot;)
def deviceId = vars.get(&quot;X-Device-Id&quot;)
def token = vars.get(&quot;X-Token&quot;)
//def token = vars.get(&quot;token_&quot; + ctx.getThreadNum()) // 使用 ctx.getThreadNum() 获取线程编号
def appVersion = vars.get(&quot;X-App-Version&quot;)
def traceId = vars.get(&quot;X-Trace-Id&quot;)
def salt = vars.get(&quot;salt&quot;)

// 创建 TreeMap 并添加参数
def headers = new TreeMap&lt;String, String&gt;()
headers.put(&quot;X-Tenant-Id&quot;, talentId)
headers.put(&quot;X-Timestamp&quot;, timestamp)
headers.put(&quot;X-Device-Id&quot;, deviceId)
headers.put(&quot;X-Token&quot;, token)
headers.put(&quot;X-App-Version&quot;, appVersion)
headers.put(&quot;X-Trace-Id&quot;, traceId)

// 生成数据字符串
def data = headers.entrySet()
    .stream()
    .map { entry -&gt; entry.getKey() + &quot;=&quot; + entry.getValue() }
    .collect(Collectors.joining(&quot;&amp;&quot;))

// 签名生成方法
def sign(String data, String salt, PrivateKey key) {
    def signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initSign(key)
    data = data + salt
    signature.update(data.getBytes())
    return new String(Base64.getEncoder().encode(signature.sign()))
}

// Base64 编码的私钥字符串
String base64PrivateKey = &quot;${PrivateKey}&quot;

// 解码 Base64 字符串为字节数组
byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey)

// 使用 KeyFactory 生成 PrivateKey 对象
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
PrivateKey key = keyFactory.generatePrivate(keySpec)

// 生成签名
def signature = sign(data, salt, key)

// 将签名存储到 JMeter 变量中
vars.put(&quot;X-Timestamp&quot;, timestamp)
vars.put(&quot;srcData&quot;, data)
vars.put(&quot;X-Sign&quot;, signature)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;sign_&quot; + ctx.getThreadNum(), signature)

// 设置全局变量（如果需要）
//props.put(&quot;X-Sign&quot;, signature)
</stringProp>
            <stringProp name="scriptLanguage">groovy</stringProp>
          </JSR223PreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="X-Timestamp" elementType="Header">
                <stringProp name="Header.name">X-Timestamp</stringProp>
                <stringProp name="Header.value">${X-Timestamp}</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON断言" enabled="true">
            <stringProp name="JSON_PATH">$.code</stringProp>
            <stringProp name="EXPECTED_VALUE">0</stringProp>
            <boolProp name="JSONVALIDATION">true</boolProp>
            <boolProp name="EXPECT_NULL">false</boolProp>
            <boolProp name="INVERT">false</boolProp>
            <boolProp name="ISREGEX">true</boolProp>
          </JSONPathAssertion>
          <hashTree/>
          <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="调试后置处理程序" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySamplerProperties">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugPostProcessor>
          <hashTree/>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="简单控制器"/>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="胜平负">
            <stringProp name="HTTPSampler.path">/api/c/user/lottery/view</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量">
              <collectionProp name="Arguments.arguments">
                <elementProp name="areaType" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.name">areaType</stringProp>
                  <stringProp name="Argument.value">1</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                </elementProp>
                <elementProp name="ratioType" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.name">ratioType</stringProp>
                  <stringProp name="Argument.value">1</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="X-Timestamp" elementType="Header">
                  <stringProp name="Header.name">X-Timestamp</stringProp>
                  <stringProp name="Header.value">${X-Timestamp}</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 预处理程序" enabled="true">
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.security.KeyFactory
import java.security.PrivateKey
import java.security.Signature
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Base64
import java.util.TreeMap
import java.util.stream.Collectors

// 定义常量
def talentId = vars.get(&quot;X-Tenant-Id&quot;)
def timestamp = System.currentTimeMillis().toString()
//def timestamp = vars.get(&quot;login-Timestamp&quot;)
def deviceId = vars.get(&quot;X-Device-Id&quot;)
def token = vars.get(&quot;X-Token&quot;)
//def token = vars.get(&quot;token_&quot; + ctx.getThreadNum()) // 使用 ctx.getThreadNum() 获取线程编号
def appVersion = vars.get(&quot;X-App-Version&quot;)
def traceId = vars.get(&quot;X-Trace-Id&quot;)
def salt = vars.get(&quot;salt&quot;)

// 创建 TreeMap 并添加参数
def headers = new TreeMap&lt;String, String&gt;()
headers.put(&quot;X-Tenant-Id&quot;, talentId)
headers.put(&quot;X-Timestamp&quot;, timestamp)
headers.put(&quot;X-Device-Id&quot;, deviceId)
headers.put(&quot;X-Token&quot;, token)
headers.put(&quot;X-App-Version&quot;, appVersion)
headers.put(&quot;X-Trace-Id&quot;, traceId)

// 生成数据字符串
def data = headers.entrySet()
    .stream()
    .map { entry -&gt; entry.getKey() + &quot;=&quot; + entry.getValue() }
    .collect(Collectors.joining(&quot;&amp;&quot;))

// 签名生成方法
def sign(String data, String salt, PrivateKey key) {
    def signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initSign(key)
    data = data + salt
    signature.update(data.getBytes())
    return new String(Base64.getEncoder().encode(signature.sign()))
}

// Base64 编码的私钥字符串
String base64PrivateKey = &quot;${PrivateKey}&quot;

// 解码 Base64 字符串为字节数组
byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey)

// 使用 KeyFactory 生成 PrivateKey 对象
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
PrivateKey key = keyFactory.generatePrivate(keySpec)

// 生成签名
def signature = sign(data, salt, key)

// 将签名存储到 JMeter 变量中
vars.put(&quot;X-Timestamp&quot;, timestamp)
vars.put(&quot;srcData&quot;, data)
vars.put(&quot;X-Sign&quot;, signature)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;sign_&quot; + ctx.getThreadNum(), signature)

// 设置全局变量（如果需要）
//props.put(&quot;X-Sign&quot;, signature)
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223PreProcessor>
            <hashTree/>
            <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON断言" enabled="true">
              <stringProp name="JSON_PATH">.code</stringProp>
              <stringProp name="EXPECTED_VALUE">0</stringProp>
              <boolProp name="JSONVALIDATION">true</boolProp>
              <boolProp name="EXPECT_NULL">false</boolProp>
              <boolProp name="INVERT">false</boolProp>
              <boolProp name="ISREGEX">true</boolProp>
            </JSONPathAssertion>
            <hashTree/>
            <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON提取器" enabled="true">
              <stringProp name="JSONPostProcessor.referenceNames">lottery;areaType</stringProp>
              <stringProp name="JSONPostProcessor.jsonPathExprs">.data[*].allLottery[*];.data[*].areaType</stringProp>
              <stringProp name="JSONPostProcessor.match_numbers">0</stringProp>
              <stringProp name="JSONPostProcessor.defaultValues">error;error</stringProp>
              <boolProp name="JSONPostProcessor.compute_concat">true</boolProp>
            </JSONPostProcessor>
            <hashTree/>
            <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON提取器" enabled="true">
              <stringProp name="JSONPostProcessor.referenceNames">matchId;shortComp;shortHome;shortAway</stringProp>
              <stringProp name="JSONPostProcessor.jsonPathExprs">.matchId;.shortComp;.shortHome;.shortAway</stringProp>
              <stringProp name="JSONPostProcessor.match_numbers">1;1;1;1</stringProp>
              <stringProp name="JSONPostProcessor.defaultValues">error;error;error;error</stringProp>
              <boolProp name="JSONPostProcessor.compute_concat">true</boolProp>
              <stringProp name="Sample.scope">variable</stringProp>
              <stringProp name="Scope.variable">lottery</stringProp>
            </JSONPostProcessor>
            <hashTree/>
            <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="JSR223 后置处理程序">
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import groovy.json.JsonSlurper
import groovy.json.JsonOutput
import groovy.json.JsonGenerator

// 示例 JSON spf数据
def jsonVar = vars.get(&quot;lottery&quot;)

// 去除不必要的反斜杠
def json01 = jsonVar.replaceAll(&quot;\\\\&quot;, &quot;&quot;)

// 解析 JSON 数据
def jsonSlurper = new JsonSlurper()
def data = jsonSlurper.parseText(json01)

// 将 JSON 中的 null 转换为 &quot;&quot;
def replaceNullWithEmptyString(obj) {
    if (obj instanceof Map) {
        obj.each { key, value -&gt; obj[key] = replaceNullWithEmptyString(value) }
    } else if (obj instanceof List) {
        obj.eachWithIndex { item, index -&gt; obj[index] = replaceNullWithEmptyString(item) }
    } else {
        return obj == null ? &quot;&quot; : obj
    }
    return obj
}

// 替换 null 值
data = replaceNullWithEmptyString(data)

// 初始化变量
def minValue = Float.MAX_VALUE
def minValueSource = &quot;&quot;
def minValueIndex = -1
def lotType = 0 // 声明 lotType 变量

// 遍历 items，找到大于等于 1.4 的最小值及其来源
data.items.eachWithIndex { item, index -&gt;
    [&quot;valuex&quot;, &quot;value&quot;, &quot;valuey&quot;].each { key -&gt;
        def value = item[key].toFloat()
        if (value &gt;= 1.4 &amp;&amp; value &lt; minValue) {
            minValue = value
            minValueSource = key
            minValueIndex = index
        }
    }
}

// 根据最小值的来源和索引设置 selectRow 和 selectCol
if (minValueIndex == 0) {
    data.selectRow = &quot;items.spf&quot;
    lotType = &quot;1&quot;
    data.selectCol = minValueSource == &quot;valuex&quot; ? &quot;3&quot; : minValueSource == &quot;value&quot; ? &quot;1&quot; : &quot;0&quot;
} else if (minValueIndex == 1) {
    data.selectRow = &quot;items.rq&quot;
    lotType = &quot;2&quot;
    data.selectCol = minValueSource == &quot;valuex&quot; ? &quot;3&quot; : minValueSource == &quot;value&quot; ? &quot;1&quot; : &quot;0&quot;
}

// 输出新的 JSON 数据
def jsonGenerator = new JsonGenerator.Options()
    .disableUnicodeEscaping() // 禁用 Unicode 转义
    .build()

def newJson = jsonGenerator.toJson(data)

// 添加反斜杠转义
def escapedJson = newJson.replaceAll(/&quot;/, &quot;\\\\\&quot;&quot;)

vars.put(&quot;lotType&quot;, lotType) 
vars.put(&quot;planDetails&quot;, escapedJson) // 将新 JSON 存储为 JMeter 变量

log.info(&quot;新 JSON 数据: &quot; + escapedJson)
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223PostProcessor>
            <hashTree/>
            <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="调试后置处理程序" enabled="true">
              <boolProp name="displayJMeterProperties">false</boolProp>
              <boolProp name="displayJMeterVariables">true</boolProp>
              <boolProp name="displaySamplerProperties">true</boolProp>
              <boolProp name="displaySystemProperties">false</boolProp>
            </DebugPostProcessor>
            <hashTree/>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="发布条件校验">
            <stringProp name="HTTPSampler.path">/api/c/user/plan/match/validate</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&quot;matchIds&quot;:&quot;${matchId}&quot;,&quot;lotType&quot;:&quot;${lotType}&quot;,&quot;areaType&quot;:&quot;${areaType}&quot;}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="X-Timestamp" elementType="Header">
                  <stringProp name="Header.name">X-Timestamp</stringProp>
                  <stringProp name="Header.value">${X-Timestamp}</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 预处理程序" enabled="true">
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import java.security.KeyFactory
import java.security.PrivateKey
import java.security.Signature
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Base64
import java.util.TreeMap
import java.util.stream.Collectors

// 定义常量
def talentId = vars.get(&quot;X-Tenant-Id&quot;)
def timestamp = System.currentTimeMillis().toString()
//def timestamp = vars.get(&quot;login-Timestamp&quot;)
def deviceId = vars.get(&quot;X-Device-Id&quot;)
def token = vars.get(&quot;X-Token&quot;)
//def token = vars.get(&quot;token_&quot; + ctx.getThreadNum()) // 使用 ctx.getThreadNum() 获取线程编号
def appVersion = vars.get(&quot;X-App-Version&quot;)
def traceId = vars.get(&quot;X-Trace-Id&quot;)
def salt = vars.get(&quot;salt&quot;)

// 创建 TreeMap 并添加参数
def headers = new TreeMap&lt;String, String&gt;()
headers.put(&quot;X-Tenant-Id&quot;, talentId)
headers.put(&quot;X-Timestamp&quot;, timestamp)
headers.put(&quot;X-Device-Id&quot;, deviceId)
headers.put(&quot;X-Token&quot;, token)
headers.put(&quot;X-App-Version&quot;, appVersion)
headers.put(&quot;X-Trace-Id&quot;, traceId)

// 生成数据字符串
def data = headers.entrySet()
    .stream()
    .map { entry -&gt; entry.getKey() + &quot;=&quot; + entry.getValue() }
    .collect(Collectors.joining(&quot;&amp;&quot;))

// 签名生成方法
def sign(String data, String salt, PrivateKey key) {
    def signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initSign(key)
    data = data + salt
    signature.update(data.getBytes())
    return new String(Base64.getEncoder().encode(signature.sign()))
}

// Base64 编码的私钥字符串
String base64PrivateKey = &quot;${PrivateKey}&quot;

// 解码 Base64 字符串为字节数组
byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey)

// 使用 KeyFactory 生成 PrivateKey 对象
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
PrivateKey key = keyFactory.generatePrivate(keySpec)

// 生成签名
def signature = sign(data, salt, key)

// 将签名存储到 JMeter 变量中
vars.put(&quot;X-Timestamp&quot;, timestamp)
vars.put(&quot;srcData&quot;, data)
vars.put(&quot;X-Sign&quot;, signature)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;sign_&quot; + ctx.getThreadNum(), signature)

// 设置全局变量（如果需要）
//props.put(&quot;X-Sign&quot;, signature)
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223PreProcessor>
            <hashTree/>
            <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON断言" enabled="true">
              <stringProp name="JSON_PATH">.code</stringProp>
              <stringProp name="EXPECTED_VALUE">0</stringProp>
              <boolProp name="JSONVALIDATION">true</boolProp>
              <boolProp name="EXPECT_NULL">false</boolProp>
              <boolProp name="INVERT">false</boolProp>
              <boolProp name="ISREGEX">true</boolProp>
            </JSONPathAssertion>
            <hashTree/>
          </hashTree>
          <IfController guiclass="IfControllerPanel" testclass="IfController" testname="IF 控制器" enabled="true">
            <stringProp name="IfController.condition">${JMeterThread.last_sample_ok}</stringProp>
            <boolProp name="IfController.evaluateAll">false</boolProp>
            <boolProp name="IfController.useExpression">true</boolProp>
          </IfController>
          <hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="胜平负/让球-发布方案">
              <stringProp name="HTTPSampler.path">/api/c/user/plan/publish</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">{&#xd;
	&quot;recommendTitle&quot;: &quot;[${shortComp}]100命中率继续带来稳单分享,胜平负总进球方向都很准。${Price}鲸&quot;,&#xd;
	&quot;planWays&quot;: 1,&#xd;
	&quot;matchIds&quot;: &quot;${matchId}&quot;,&#xd;
	&quot;planDetailIds&quot;: &quot;${planDetailIds}&quot;,&#xd;
	&quot;lotClass&quot;: 1,&#xd;
	&quot;isFree&quot;: ${isFree},&#xd;
	&quot;planDetails&quot;:&quot;[${planDetails}]&quot;,&#xd;
	&quot;lotType&quot;: &quot;${lotType}&quot;,&#xd;
	&quot;discountPrice&quot;: ${Price},&#xd;
	&quot;areaType&quot;: &quot;${areaType}&quot;,&#xd;
	&quot;sportType&quot;: &quot;1&quot;,&#xd;
	&quot;recommendContent&quot;: &quot;本方案中的${shortComp}赛事(${matchId})的主队${shortHome}近期状态不错。\n除了结合指数和${shortHome}、${shortAway}历史交锋数据，还有很重要的是能分清楚烟雾弹，排除机构给出来的陷阱，因此也考验一个人的能力。多看多总结，总能找到属于你自己的规律。\n本场胜负方向，${shortAway}不败。本场进球总数方向，2球以上&quot;&#xd;
}&#xd;
</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <GaussianRandomTimer guiclass="GaussianRandomTimerGui" testclass="GaussianRandomTimer" testname="高斯随机定时器" enabled="false">
                <stringProp name="ConstantTimer.delay">81000</stringProp>
                <stringProp name="RandomTimer.range">21000</stringProp>
              </GaussianRandomTimer>
              <hashTree/>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="X-Timestamp" elementType="Header">
                    <stringProp name="Header.name">X-Timestamp</stringProp>
                    <stringProp name="Header.value">${X-Timestamp}</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 预处理程序" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import java.security.KeyFactory
import java.security.PrivateKey
import java.security.Signature
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Base64
import java.util.TreeMap
import java.util.stream.Collectors

// 定义常量
def talentId = vars.get(&quot;X-Tenant-Id&quot;)
def timestamp = System.currentTimeMillis().toString()
//def timestamp = vars.get(&quot;login-Timestamp&quot;)
def deviceId = vars.get(&quot;X-Device-Id&quot;)
def token = vars.get(&quot;X-Token&quot;)
//def token = vars.get(&quot;token_&quot; + ctx.getThreadNum()) // 使用 ctx.getThreadNum() 获取线程编号
def appVersion = vars.get(&quot;X-App-Version&quot;)
def traceId = vars.get(&quot;X-Trace-Id&quot;)
def salt = vars.get(&quot;salt&quot;)

// 创建 TreeMap 并添加参数
def headers = new TreeMap&lt;String, String&gt;()
headers.put(&quot;X-Tenant-Id&quot;, talentId)
headers.put(&quot;X-Timestamp&quot;, timestamp)
headers.put(&quot;X-Device-Id&quot;, deviceId)
headers.put(&quot;X-Token&quot;, token)
headers.put(&quot;X-App-Version&quot;, appVersion)
headers.put(&quot;X-Trace-Id&quot;, traceId)

// 生成数据字符串
def data = headers.entrySet()
    .stream()
    .map { entry -&gt; entry.getKey() + &quot;=&quot; + entry.getValue() }
    .collect(Collectors.joining(&quot;&amp;&quot;))

// 签名生成方法
def sign(String data, String salt, PrivateKey key) {
    def signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initSign(key)
    data = data + salt
    signature.update(data.getBytes())
    return new String(Base64.getEncoder().encode(signature.sign()))
}

// Base64 编码的私钥字符串
String base64PrivateKey = &quot;${PrivateKey}&quot;

// 解码 Base64 字符串为字节数组
byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey)

// 使用 KeyFactory 生成 PrivateKey 对象
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
PrivateKey key = keyFactory.generatePrivate(keySpec)

// 生成签名
def signature = sign(data, salt, key)

// 将签名存储到 JMeter 变量中
vars.put(&quot;X-Timestamp&quot;, timestamp)
vars.put(&quot;srcData&quot;, data)
vars.put(&quot;X-Sign&quot;, signature)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;sign_&quot; + ctx.getThreadNum(), signature)

// 设置全局变量（如果需要）
//props.put(&quot;X-Sign&quot;, signature)
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PreProcessor>
              <hashTree/>
              <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON断言" enabled="true">
                <stringProp name="JSON_PATH">.code</stringProp>
                <stringProp name="EXPECTED_VALUE">0</stringProp>
                <boolProp name="JSONVALIDATION">true</boolProp>
                <boolProp name="EXPECT_NULL">false</boolProp>
                <boolProp name="INVERT">false</boolProp>
                <boolProp name="ISREGEX">true</boolProp>
              </JSONPathAssertion>
              <hashTree/>
              <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="调试后置处理程序">
                <boolProp name="displayJMeterProperties">false</boolProp>
                <boolProp name="displayJMeterVariables">true</boolProp>
                <boolProp name="displaySamplerProperties">true</boolProp>
                <boolProp name="displaySystemProperties">false</boolProp>
              </DebugPostProcessor>
              <hashTree/>
            </hashTree>
          </hashTree>
        </hashTree>
        <RandomController guiclass="RandomControlGui" testclass="RandomController" testname="随机控制器" enabled="false">
          <intProp name="InterleaveControl.style">1</intProp>
        </RandomController>
        <hashTree>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="简单控制器" enabled="true"/>
          <hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="欧指" enabled="true">
              <stringProp name="HTTPSampler.path">/api/c/user/lottery/view</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <stringProp name="HTTPSampler.method">GET</stringProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="areaType" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.name">areaType</stringProp>
                    <stringProp name="Argument.value">2</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  </elementProp>
                  <elementProp name="ratioType" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.name">ratioType</stringProp>
                    <stringProp name="Argument.value">1</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="X-Timestamp" elementType="Header">
                    <stringProp name="Header.name">X-Timestamp</stringProp>
                    <stringProp name="Header.value">${X-Timestamp}</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 预处理程序" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import java.security.KeyFactory
import java.security.PrivateKey
import java.security.Signature
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Base64
import java.util.TreeMap
import java.util.stream.Collectors

// 定义常量
def talentId = vars.get(&quot;X-Tenant-Id&quot;)
def timestamp = System.currentTimeMillis().toString()
//def timestamp = vars.get(&quot;login-Timestamp&quot;)
def deviceId = vars.get(&quot;X-Device-Id&quot;)
def token = vars.get(&quot;X-Token&quot;)
//def token = vars.get(&quot;token_&quot; + ctx.getThreadNum()) // 使用 ctx.getThreadNum() 获取线程编号
def appVersion = vars.get(&quot;X-App-Version&quot;)
def traceId = vars.get(&quot;X-Trace-Id&quot;)
def salt = vars.get(&quot;salt&quot;)

// 创建 TreeMap 并添加参数
def headers = new TreeMap&lt;String, String&gt;()
headers.put(&quot;X-Tenant-Id&quot;, talentId)
headers.put(&quot;X-Timestamp&quot;, timestamp)
headers.put(&quot;X-Device-Id&quot;, deviceId)
headers.put(&quot;X-Token&quot;, token)
headers.put(&quot;X-App-Version&quot;, appVersion)
headers.put(&quot;X-Trace-Id&quot;, traceId)

// 生成数据字符串
def data = headers.entrySet()
    .stream()
    .map { entry -&gt; entry.getKey() + &quot;=&quot; + entry.getValue() }
    .collect(Collectors.joining(&quot;&amp;&quot;))

// 签名生成方法
def sign(String data, String salt, PrivateKey key) {
    def signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initSign(key)
    data = data + salt
    signature.update(data.getBytes())
    return new String(Base64.getEncoder().encode(signature.sign()))
}

// Base64 编码的私钥字符串
String base64PrivateKey = &quot;${PrivateKey}&quot;

// 解码 Base64 字符串为字节数组
byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey)

// 使用 KeyFactory 生成 PrivateKey 对象
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
PrivateKey key = keyFactory.generatePrivate(keySpec)

// 生成签名
def signature = sign(data, salt, key)

// 将签名存储到 JMeter 变量中
vars.put(&quot;X-Timestamp&quot;, timestamp)
vars.put(&quot;srcData&quot;, data)
vars.put(&quot;X-Sign&quot;, signature)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;sign_&quot; + ctx.getThreadNum(), signature)

// 设置全局变量（如果需要）
//props.put(&quot;X-Sign&quot;, signature)
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PreProcessor>
              <hashTree/>
              <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON断言" enabled="true">
                <stringProp name="JSON_PATH">.code</stringProp>
                <stringProp name="EXPECTED_VALUE">0</stringProp>
                <boolProp name="JSONVALIDATION">true</boolProp>
                <boolProp name="EXPECT_NULL">false</boolProp>
                <boolProp name="INVERT">false</boolProp>
                <boolProp name="ISREGEX">true</boolProp>
              </JSONPathAssertion>
              <hashTree/>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON提取器" enabled="true">
                <stringProp name="JSONPostProcessor.referenceNames">lottery;areaType</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">.data[-1].allLottery[*];.data[-1].areaType</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers">0</stringProp>
                <stringProp name="JSONPostProcessor.defaultValues">error;error</stringProp>
                <boolProp name="JSONPostProcessor.compute_concat">true</boolProp>
              </JSONPostProcessor>
              <hashTree/>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON提取器" enabled="true">
                <stringProp name="JSONPostProcessor.referenceNames">matchId;shortComp;shortHome;shortAway</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">.matchId;.shortComp;.shortHome;.shortAway</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers">1;1;1;1</stringProp>
                <stringProp name="JSONPostProcessor.defaultValues">error;error;error;error</stringProp>
                <boolProp name="JSONPostProcessor.compute_concat">true</boolProp>
                <stringProp name="Sample.scope">variable</stringProp>
                <stringProp name="Scope.variable">lottery</stringProp>
              </JSONPostProcessor>
              <hashTree/>
              <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="JSR223 后置处理程序" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import groovy.json.JsonSlurper
import groovy.json.JsonOutput
import groovy.json.JsonGenerator

// 示例 JSON spf数据
def jsonVar = vars.get(&quot;lottery&quot;)

// 去除不必要的反斜杠
def json01 = jsonVar.replaceAll(&quot;\\\\&quot;, &quot;&quot;)

// 解析 JSON 数据
def jsonSlurper = new JsonSlurper()
def data = jsonSlurper.parseText(json01)

// 将 JSON 中的 null 转换为 &quot;&quot;
def replaceNullWithEmptyString(obj) {
    if (obj instanceof Map) {
        obj.each { key, value -&gt; obj[key] = replaceNullWithEmptyString(value) }
    } else if (obj instanceof List) {
        obj.eachWithIndex { item, index -&gt; obj[index] = replaceNullWithEmptyString(item) }
    } else {
        return obj == null ? &quot;&quot; : obj
    }
    return obj
}

// 替换 null 值
data = replaceNullWithEmptyString(data)

// 初始化变量
def minValue = Float.MAX_VALUE
def minValueSource = &quot;&quot;
def minValueIndex = -1
def lotType = 0 // 声明 lotType 变量

// 遍历 items，找到大于等于 1.4 的最小值及其来源
data.items.eachWithIndex { item, index -&gt;
    [&quot;valuex&quot;, &quot;value&quot;, &quot;valuey&quot;].each { key -&gt;
        def value = item[key].toFloat()
        if (value &gt;= 1.4 &amp;&amp; value &lt; minValue) {
            minValue = value
            minValueSource = key
            minValueIndex = index
        }
    }
}

// 根据最小值的来源和索引设置 selectRow 和 selectCol
if (minValueIndex == 0) {
    data.selectRow = &quot;items.spf&quot;
    lotType = &quot;1&quot;
    data.selectCol = minValueSource == &quot;valuex&quot; ? &quot;3&quot; : minValueSource == &quot;value&quot; ? &quot;1&quot; : &quot;0&quot;
} else if (minValueIndex == 1) {
    data.selectRow = &quot;items.rq&quot;
    lotType = &quot;2&quot;
    data.selectCol = minValueSource == &quot;valuex&quot; ? &quot;3&quot; : minValueSource == &quot;value&quot; ? &quot;1&quot; : &quot;0&quot;
}

// 输出新的 JSON 数据
def jsonGenerator = new JsonGenerator.Options()
    .disableUnicodeEscaping() // 禁用 Unicode 转义
    .build()

def newJson = jsonGenerator.toJson(data)

// 添加反斜杠转义
def escapedJson = newJson.replaceAll(/&quot;/, &quot;\\\\\&quot;&quot;)

vars.put(&quot;lotType&quot;, lotType) 
vars.put(&quot;planDetails&quot;, escapedJson) // 将新 JSON 存储为 JMeter 变量

log.info(&quot;新 JSON 数据: &quot; + escapedJson)
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PostProcessor>
              <hashTree/>
              <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="调试后置处理程序" enabled="true">
                <boolProp name="displayJMeterProperties">false</boolProp>
                <boolProp name="displayJMeterVariables">true</boolProp>
                <boolProp name="displaySamplerProperties">true</boolProp>
                <boolProp name="displaySystemProperties">false</boolProp>
              </DebugPostProcessor>
              <hashTree/>
            </hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="发布条件校验" enabled="true">
              <stringProp name="HTTPSampler.path">/api/c/user/plan/match/validate</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">{&quot;matchIds&quot;:&quot;${matchId}&quot;,&quot;lotType&quot;:&quot;${lotType}&quot;,&quot;areaType&quot;:&quot;${areaType}&quot;}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="X-Timestamp" elementType="Header">
                    <stringProp name="Header.name">X-Timestamp</stringProp>
                    <stringProp name="Header.value">${X-Timestamp}</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 预处理程序" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import java.security.KeyFactory
import java.security.PrivateKey
import java.security.Signature
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Base64
import java.util.TreeMap
import java.util.stream.Collectors

// 定义常量
def talentId = vars.get(&quot;X-Tenant-Id&quot;)
def timestamp = System.currentTimeMillis().toString()
//def timestamp = vars.get(&quot;login-Timestamp&quot;)
def deviceId = vars.get(&quot;X-Device-Id&quot;)
def token = vars.get(&quot;X-Token&quot;)
//def token = vars.get(&quot;token_&quot; + ctx.getThreadNum()) // 使用 ctx.getThreadNum() 获取线程编号
def appVersion = vars.get(&quot;X-App-Version&quot;)
def traceId = vars.get(&quot;X-Trace-Id&quot;)
def salt = vars.get(&quot;salt&quot;)

// 创建 TreeMap 并添加参数
def headers = new TreeMap&lt;String, String&gt;()
headers.put(&quot;X-Tenant-Id&quot;, talentId)
headers.put(&quot;X-Timestamp&quot;, timestamp)
headers.put(&quot;X-Device-Id&quot;, deviceId)
headers.put(&quot;X-Token&quot;, token)
headers.put(&quot;X-App-Version&quot;, appVersion)
headers.put(&quot;X-Trace-Id&quot;, traceId)

// 生成数据字符串
def data = headers.entrySet()
    .stream()
    .map { entry -&gt; entry.getKey() + &quot;=&quot; + entry.getValue() }
    .collect(Collectors.joining(&quot;&amp;&quot;))

// 签名生成方法
def sign(String data, String salt, PrivateKey key) {
    def signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initSign(key)
    data = data + salt
    signature.update(data.getBytes())
    return new String(Base64.getEncoder().encode(signature.sign()))
}

// Base64 编码的私钥字符串
String base64PrivateKey = &quot;${PrivateKey}&quot;

// 解码 Base64 字符串为字节数组
byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey)

// 使用 KeyFactory 生成 PrivateKey 对象
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
PrivateKey key = keyFactory.generatePrivate(keySpec)

// 生成签名
def signature = sign(data, salt, key)

// 将签名存储到 JMeter 变量中
vars.put(&quot;X-Timestamp&quot;, timestamp)
vars.put(&quot;srcData&quot;, data)
vars.put(&quot;X-Sign&quot;, signature)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;sign_&quot; + ctx.getThreadNum(), signature)

// 设置全局变量（如果需要）
//props.put(&quot;X-Sign&quot;, signature)
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PreProcessor>
              <hashTree/>
              <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON断言" enabled="true">
                <stringProp name="JSON_PATH">.code</stringProp>
                <stringProp name="EXPECTED_VALUE">0</stringProp>
                <boolProp name="JSONVALIDATION">true</boolProp>
                <boolProp name="EXPECT_NULL">false</boolProp>
                <boolProp name="INVERT">false</boolProp>
                <boolProp name="ISREGEX">true</boolProp>
              </JSONPathAssertion>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="IF 控制器" enabled="true">
              <stringProp name="IfController.condition">${JMeterThread.last_sample_ok}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="欧指-发布方案" enabled="true">
                <stringProp name="HTTPSampler.path">/api/c/user/plan/publish</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">{&#xd;
	&quot;recommendTitle&quot;: &quot;[${shortComp}]100命中率继续带来稳单分享,胜平负总进球方向都很准。${Price}鲸&quot;,&#xd;
	&quot;planWays&quot;: 1,&#xd;
	&quot;matchIds&quot;: &quot;${matchId}&quot;,&#xd;
	&quot;planDetailIds&quot;: &quot;${planDetailIds}&quot;,&#xd;
	&quot;lotClass&quot;: 11,&#xd;
	&quot;isFree&quot;: ${isFree},&#xd;
	&quot;planDetails&quot;:&quot;[${planDetails}]&quot;,&#xd;
	&quot;lotType&quot;: &quot;${lotType}&quot;,&#xd;
	&quot;discountPrice&quot;: ${Price},&#xd;
	&quot;areaType&quot;: &quot;${areaType}&quot;,&#xd;
	&quot;sportType&quot;: &quot;1&quot;,&#xd;
	&quot;recommendContent&quot;: &quot;本方案中的${shortComp}赛事(${matchId})的主队${shortHome}近期状态不错。\n除了结合指数和${shortHome}、${shortAway}历史交锋数据，还有很重要的是能分清楚烟雾弹，排除机构给出来的陷阱，因此也考验一个人的能力。多看多总结，总能找到属于你自己的规律。\n本场胜负方向，${shortAway}不败。本场进球总数方向，1球以上&quot;&#xd;
}&#xd;
</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <GaussianRandomTimer guiclass="GaussianRandomTimerGui" testclass="GaussianRandomTimer" testname="高斯随机定时器" enabled="true">
                  <stringProp name="ConstantTimer.delay">101000</stringProp>
                  <stringProp name="RandomTimer.range">51000</stringProp>
                </GaussianRandomTimer>
                <hashTree/>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="X-Timestamp" elementType="Header">
                      <stringProp name="Header.name">X-Timestamp</stringProp>
                      <stringProp name="Header.value">${X-Timestamp}</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
                <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 预处理程序" enabled="true">
                  <stringProp name="cacheKey">true</stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="script">import java.security.KeyFactory
import java.security.PrivateKey
import java.security.Signature
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Base64
import java.util.TreeMap
import java.util.stream.Collectors

// 定义常量
def talentId = vars.get(&quot;X-Tenant-Id&quot;)
def timestamp = System.currentTimeMillis().toString()
//def timestamp = vars.get(&quot;login-Timestamp&quot;)
def deviceId = vars.get(&quot;X-Device-Id&quot;)
def token = vars.get(&quot;X-Token&quot;)
//def token = vars.get(&quot;token_&quot; + ctx.getThreadNum()) // 使用 ctx.getThreadNum() 获取线程编号
def appVersion = vars.get(&quot;X-App-Version&quot;)
def traceId = vars.get(&quot;X-Trace-Id&quot;)
def salt = vars.get(&quot;salt&quot;)

// 创建 TreeMap 并添加参数
def headers = new TreeMap&lt;String, String&gt;()
headers.put(&quot;X-Tenant-Id&quot;, talentId)
headers.put(&quot;X-Timestamp&quot;, timestamp)
headers.put(&quot;X-Device-Id&quot;, deviceId)
headers.put(&quot;X-Token&quot;, token)
headers.put(&quot;X-App-Version&quot;, appVersion)
headers.put(&quot;X-Trace-Id&quot;, traceId)

// 生成数据字符串
def data = headers.entrySet()
    .stream()
    .map { entry -&gt; entry.getKey() + &quot;=&quot; + entry.getValue() }
    .collect(Collectors.joining(&quot;&amp;&quot;))

// 签名生成方法
def sign(String data, String salt, PrivateKey key) {
    def signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initSign(key)
    data = data + salt
    signature.update(data.getBytes())
    return new String(Base64.getEncoder().encode(signature.sign()))
}

// Base64 编码的私钥字符串
String base64PrivateKey = &quot;${PrivateKey}&quot;

// 解码 Base64 字符串为字节数组
byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey)

// 使用 KeyFactory 生成 PrivateKey 对象
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
PrivateKey key = keyFactory.generatePrivate(keySpec)

// 生成签名
def signature = sign(data, salt, key)

// 将签名存储到 JMeter 变量中
vars.put(&quot;X-Timestamp&quot;, timestamp)
vars.put(&quot;srcData&quot;, data)
vars.put(&quot;X-Sign&quot;, signature)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;sign_&quot; + ctx.getThreadNum(), signature)

// 设置全局变量（如果需要）
//props.put(&quot;X-Sign&quot;, signature)
</stringProp>
                  <stringProp name="scriptLanguage">groovy</stringProp>
                </JSR223PreProcessor>
                <hashTree/>
                <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON断言" enabled="true">
                  <stringProp name="JSON_PATH">.code</stringProp>
                  <stringProp name="EXPECTED_VALUE">0</stringProp>
                  <boolProp name="JSONVALIDATION">true</boolProp>
                  <boolProp name="EXPECT_NULL">false</boolProp>
                  <boolProp name="INVERT">false</boolProp>
                  <boolProp name="ISREGEX">true</boolProp>
                </JSONPathAssertion>
                <hashTree/>
                <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="调试后置处理程序" enabled="true">
                  <boolProp name="displayJMeterProperties">false</boolProp>
                  <boolProp name="displayJMeterVariables">true</boolProp>
                  <boolProp name="displaySamplerProperties">true</boolProp>
                  <boolProp name="displaySystemProperties">false</boolProp>
                </DebugPostProcessor>
                <hashTree/>
              </hashTree>
            </hashTree>
          </hashTree>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="简单控制器" enabled="true"/>
          <hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="亚指" enabled="true">
              <stringProp name="HTTPSampler.path">/api/c/user/lottery/view</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <stringProp name="HTTPSampler.method">GET</stringProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="areaType" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.name">areaType</stringProp>
                    <stringProp name="Argument.value">2</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  </elementProp>
                  <elementProp name="ratioType" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.name">ratioType</stringProp>
                    <stringProp name="Argument.value">2</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="X-Timestamp" elementType="Header">
                    <stringProp name="Header.name">X-Timestamp</stringProp>
                    <stringProp name="Header.value">${X-Timestamp}</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 预处理程序" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import java.security.KeyFactory
import java.security.PrivateKey
import java.security.Signature
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Base64
import java.util.TreeMap
import java.util.stream.Collectors

// 定义常量
def talentId = vars.get(&quot;X-Tenant-Id&quot;)
def timestamp = System.currentTimeMillis().toString()
//def timestamp = vars.get(&quot;login-Timestamp&quot;)
def deviceId = vars.get(&quot;X-Device-Id&quot;)
def token = vars.get(&quot;X-Token&quot;)
//def token = vars.get(&quot;token_&quot; + ctx.getThreadNum()) // 使用 ctx.getThreadNum() 获取线程编号
def appVersion = vars.get(&quot;X-App-Version&quot;)
def traceId = vars.get(&quot;X-Trace-Id&quot;)
def salt = vars.get(&quot;salt&quot;)

// 创建 TreeMap 并添加参数
def headers = new TreeMap&lt;String, String&gt;()
headers.put(&quot;X-Tenant-Id&quot;, talentId)
headers.put(&quot;X-Timestamp&quot;, timestamp)
headers.put(&quot;X-Device-Id&quot;, deviceId)
headers.put(&quot;X-Token&quot;, token)
headers.put(&quot;X-App-Version&quot;, appVersion)
headers.put(&quot;X-Trace-Id&quot;, traceId)

// 生成数据字符串
def data = headers.entrySet()
    .stream()
    .map { entry -&gt; entry.getKey() + &quot;=&quot; + entry.getValue() }
    .collect(Collectors.joining(&quot;&amp;&quot;))

// 签名生成方法
def sign(String data, String salt, PrivateKey key) {
    def signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initSign(key)
    data = data + salt
    signature.update(data.getBytes())
    return new String(Base64.getEncoder().encode(signature.sign()))
}

// Base64 编码的私钥字符串
String base64PrivateKey = &quot;${PrivateKey}&quot;

// 解码 Base64 字符串为字节数组
byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey)

// 使用 KeyFactory 生成 PrivateKey 对象
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
PrivateKey key = keyFactory.generatePrivate(keySpec)

// 生成签名
def signature = sign(data, salt, key)

// 将签名存储到 JMeter 变量中
vars.put(&quot;X-Timestamp&quot;, timestamp)
vars.put(&quot;srcData&quot;, data)
vars.put(&quot;X-Sign&quot;, signature)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;sign_&quot; + ctx.getThreadNum(), signature)

// 设置全局变量（如果需要）
//props.put(&quot;X-Sign&quot;, signature)
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PreProcessor>
              <hashTree/>
              <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON断言" enabled="true">
                <stringProp name="JSON_PATH">.code</stringProp>
                <stringProp name="EXPECTED_VALUE">0</stringProp>
                <boolProp name="JSONVALIDATION">true</boolProp>
                <boolProp name="EXPECT_NULL">false</boolProp>
                <boolProp name="INVERT">false</boolProp>
                <boolProp name="ISREGEX">true</boolProp>
              </JSONPathAssertion>
              <hashTree/>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON提取器" enabled="true">
                <stringProp name="JSONPostProcessor.referenceNames">lottery;areaType</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">.data[-1].allLottery[*];.data[-1].areaType</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers">0</stringProp>
                <stringProp name="JSONPostProcessor.defaultValues">error;error</stringProp>
                <boolProp name="JSONPostProcessor.compute_concat">true</boolProp>
              </JSONPostProcessor>
              <hashTree/>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON提取器" enabled="true">
                <stringProp name="JSONPostProcessor.referenceNames">matchId;shortComp;shortHome;shortAway</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">.matchId;.shortComp;.shortHome;.shortAway</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers">1;1;1;1</stringProp>
                <stringProp name="JSONPostProcessor.defaultValues">error;error;error;error</stringProp>
                <boolProp name="JSONPostProcessor.compute_concat">true</boolProp>
                <stringProp name="Sample.scope">variable</stringProp>
                <stringProp name="Scope.variable">lottery</stringProp>
              </JSONPostProcessor>
              <hashTree/>
              <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="JSR223 后置处理程序" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import groovy.json.JsonSlurper
import groovy.json.JsonOutput
import groovy.json.JsonGenerator

// 示例 JSON 数据
def jsonVar = vars.get(&quot;lottery&quot;)

// 去除不必要的反斜杠
def json01 = jsonVar.replaceAll(&quot;\\\\&quot;, &quot;&quot;)

// 解析 JSON 数据
def jsonSlurper = new JsonSlurper()
def data = jsonSlurper.parseText(json01)

// 将 JSON 中的 null 转换为 &quot;&quot;
def replaceNullWithEmptyString(obj) {
    if (obj instanceof Map) {
        obj.each { key, value -&gt; obj[key] = replaceNullWithEmptyString(value) }
    } else if (obj instanceof List) {
        obj.eachWithIndex { item, index -&gt; obj[index] = replaceNullWithEmptyString(item) }
    } else {
        return obj == null ? &quot;&quot; : obj
    }
    return obj
}

// 替换 null 值
data = replaceNullWithEmptyString(data)

// 初始化变量
def minValue = Float.MAX_VALUE
def minValueSource = &quot;&quot;
def lotType = 0 // 声明 lotType 变量

// 遍历 items，找到最小值及其来源
data.items.each { item -&gt;
    [&quot;valuex&quot;, &quot;valuey&quot;].each { key -&gt;
        def value = item[key].toFloat()
        if (value &lt; minValue) {
            minValue = value
            minValueSource = key
        }
    }
}

// 根据最小值的来源设置 selectRow 和 selectCol
if (minValueSource == &quot;valuex&quot;) {
    data.selectRow = &quot;items.spf&quot;
    data.selectCol = &quot;3&quot;
} else if (minValueSource == &quot;valuey&quot;) {
    data.selectRow = &quot;items.spf&quot;
    data.selectCol = &quot;0&quot;
}

// 输出新的 JSON 数据
def jsonGenerator = new JsonGenerator.Options()
    .disableUnicodeEscaping() // 禁用 Unicode 转义
    .build()

def newJson = jsonGenerator.toJson(data)

// 添加反斜杠转义
def escapedJson = newJson.replaceAll(/&quot;/, &quot;\\\\\&quot;&quot;)

vars.put(&quot;planDetails&quot;, escapedJson) // 将新 JSON 存储为 JMeter 变量
log.info(&quot;新 JSON 数据: &quot; + escapedJson)
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PostProcessor>
              <hashTree/>
              <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="调试后置处理程序" enabled="true">
                <boolProp name="displayJMeterProperties">false</boolProp>
                <boolProp name="displayJMeterVariables">true</boolProp>
                <boolProp name="displaySamplerProperties">true</boolProp>
                <boolProp name="displaySystemProperties">false</boolProp>
              </DebugPostProcessor>
              <hashTree/>
            </hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="发布条件校验" enabled="true">
              <stringProp name="HTTPSampler.path">/api/c/user/plan/match/validate</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">{&quot;matchIds&quot;:&quot;${matchId}&quot;,&quot;lotType&quot;:&quot;${lotType}&quot;,&quot;areaType&quot;:&quot;${areaType}&quot;}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="X-Timestamp" elementType="Header">
                    <stringProp name="Header.name">X-Timestamp</stringProp>
                    <stringProp name="Header.value">${X-Timestamp}</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 预处理程序" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import java.security.KeyFactory
import java.security.PrivateKey
import java.security.Signature
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Base64
import java.util.TreeMap
import java.util.stream.Collectors

// 定义常量
def talentId = vars.get(&quot;X-Tenant-Id&quot;)
def timestamp = System.currentTimeMillis().toString()
//def timestamp = vars.get(&quot;login-Timestamp&quot;)
def deviceId = vars.get(&quot;X-Device-Id&quot;)
def token = vars.get(&quot;X-Token&quot;)
//def token = vars.get(&quot;token_&quot; + ctx.getThreadNum()) // 使用 ctx.getThreadNum() 获取线程编号
def appVersion = vars.get(&quot;X-App-Version&quot;)
def traceId = vars.get(&quot;X-Trace-Id&quot;)
def salt = vars.get(&quot;salt&quot;)

// 创建 TreeMap 并添加参数
def headers = new TreeMap&lt;String, String&gt;()
headers.put(&quot;X-Tenant-Id&quot;, talentId)
headers.put(&quot;X-Timestamp&quot;, timestamp)
headers.put(&quot;X-Device-Id&quot;, deviceId)
headers.put(&quot;X-Token&quot;, token)
headers.put(&quot;X-App-Version&quot;, appVersion)
headers.put(&quot;X-Trace-Id&quot;, traceId)

// 生成数据字符串
def data = headers.entrySet()
    .stream()
    .map { entry -&gt; entry.getKey() + &quot;=&quot; + entry.getValue() }
    .collect(Collectors.joining(&quot;&amp;&quot;))

// 签名生成方法
def sign(String data, String salt, PrivateKey key) {
    def signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initSign(key)
    data = data + salt
    signature.update(data.getBytes())
    return new String(Base64.getEncoder().encode(signature.sign()))
}

// Base64 编码的私钥字符串
String base64PrivateKey = &quot;${PrivateKey}&quot;

// 解码 Base64 字符串为字节数组
byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey)

// 使用 KeyFactory 生成 PrivateKey 对象
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
PrivateKey key = keyFactory.generatePrivate(keySpec)

// 生成签名
def signature = sign(data, salt, key)

// 将签名存储到 JMeter 变量中
vars.put(&quot;X-Timestamp&quot;, timestamp)
vars.put(&quot;srcData&quot;, data)
vars.put(&quot;X-Sign&quot;, signature)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;sign_&quot; + ctx.getThreadNum(), signature)

// 设置全局变量（如果需要）
//props.put(&quot;X-Sign&quot;, signature)
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PreProcessor>
              <hashTree/>
              <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON断言" enabled="true">
                <stringProp name="JSON_PATH">.code</stringProp>
                <stringProp name="EXPECTED_VALUE">0</stringProp>
                <boolProp name="JSONVALIDATION">true</boolProp>
                <boolProp name="EXPECT_NULL">false</boolProp>
                <boolProp name="INVERT">false</boolProp>
                <boolProp name="ISREGEX">true</boolProp>
              </JSONPathAssertion>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="IF 控制器" enabled="true">
              <stringProp name="IfController.condition">${JMeterThread.last_sample_ok}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="亚指-发布方案" enabled="true">
                <stringProp name="HTTPSampler.path">/api/c/user/plan/publish</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">{&#xd;
	&quot;recommendTitle&quot;: &quot;[${shortComp}]100命中率继续带来稳单分享,胜平负总进球方向都很准。${Price}鲸&quot;,&#xd;
	&quot;planWays&quot;: 1,&#xd;
	&quot;matchIds&quot;: &quot;${matchId}&quot;,&#xd;
	&quot;planDetailIds&quot;: &quot;${planDetailIds}&quot;,&#xd;
	&quot;lotClass&quot;: 11,&#xd;
	&quot;isFree&quot;: ${isFree},&#xd;
	&quot;planDetails&quot;:&quot;[${planDetails}]&quot;,&#xd;
	&quot;lotType&quot;: &quot;2&quot;,&#xd;
	&quot;discountPrice&quot;: ${Price},&#xd;
	&quot;areaType&quot;: &quot;${areaType}&quot;,&#xd;
	&quot;sportType&quot;: &quot;1&quot;,&#xd;
	&quot;recommendContent&quot;: &quot;本方案中的${shortComp}赛事(${matchId})主队${shortHome}近期状态不错,${shortAway}也实力不俗。\n除了结合指数和${shortHome}、${shortAway}历史交锋数据，还有很重要的是能分清楚烟雾弹，排除机构给出来的陷阱，因此也考验一个人的能力。多看多总结，总能找到属于你自己的规律。\n本场胜负方向，${shortAway}不败。本场进球总数方向，2球以上&quot;&#xd;
}&#xd;
</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <GaussianRandomTimer guiclass="GaussianRandomTimerGui" testclass="GaussianRandomTimer" testname="高斯随机定时器" enabled="true">
                  <stringProp name="ConstantTimer.delay">101000</stringProp>
                  <stringProp name="RandomTimer.range">5100</stringProp>
                </GaussianRandomTimer>
                <hashTree/>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="X-Timestamp" elementType="Header">
                      <stringProp name="Header.name">X-Timestamp</stringProp>
                      <stringProp name="Header.value">${X-Timestamp}</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
                <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="X-Timestamp" elementType="Argument">
                      <stringProp name="Argument.name">X-Timestamp</stringProp>
                      <stringProp name="Argument.value">${__time(,)}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                    </elementProp>
                  </collectionProp>
                </Arguments>
                <hashTree/>
                <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 预处理程序" enabled="true">
                  <stringProp name="cacheKey">true</stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="script">import java.security.KeyFactory
import java.security.PrivateKey
import java.security.Signature
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Base64
import java.util.TreeMap
import java.util.stream.Collectors

// 定义常量
def talentId = vars.get(&quot;X-Tenant-Id&quot;)
def timestamp = System.currentTimeMillis().toString()
//def timestamp = vars.get(&quot;login-Timestamp&quot;)
def deviceId = vars.get(&quot;X-Device-Id&quot;)
def token = vars.get(&quot;X-Token&quot;)
//def token = vars.get(&quot;token_&quot; + ctx.getThreadNum()) // 使用 ctx.getThreadNum() 获取线程编号
def appVersion = vars.get(&quot;X-App-Version&quot;)
def traceId = vars.get(&quot;X-Trace-Id&quot;)
def salt = vars.get(&quot;salt&quot;)

// 创建 TreeMap 并添加参数
def headers = new TreeMap&lt;String, String&gt;()
headers.put(&quot;X-Tenant-Id&quot;, talentId)
headers.put(&quot;X-Timestamp&quot;, timestamp)
headers.put(&quot;X-Device-Id&quot;, deviceId)
headers.put(&quot;X-Token&quot;, token)
headers.put(&quot;X-App-Version&quot;, appVersion)
headers.put(&quot;X-Trace-Id&quot;, traceId)

// 生成数据字符串
def data = headers.entrySet()
    .stream()
    .map { entry -&gt; entry.getKey() + &quot;=&quot; + entry.getValue() }
    .collect(Collectors.joining(&quot;&amp;&quot;))

// 签名生成方法
def sign(String data, String salt, PrivateKey key) {
    def signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initSign(key)
    data = data + salt
    signature.update(data.getBytes())
    return new String(Base64.getEncoder().encode(signature.sign()))
}

// Base64 编码的私钥字符串
String base64PrivateKey = &quot;${PrivateKey}&quot;

// 解码 Base64 字符串为字节数组
byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey)

// 使用 KeyFactory 生成 PrivateKey 对象
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
PrivateKey key = keyFactory.generatePrivate(keySpec)

// 生成签名
def signature = sign(data, salt, key)

// 将签名存储到 JMeter 变量中
vars.put(&quot;X-Timestamp&quot;, timestamp)
vars.put(&quot;srcData&quot;, data)
vars.put(&quot;X-Sign&quot;, signature)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;sign_&quot; + ctx.getThreadNum(), signature)

// 设置全局变量（如果需要）
//props.put(&quot;X-Sign&quot;, signature)
</stringProp>
                  <stringProp name="scriptLanguage">groovy</stringProp>
                </JSR223PreProcessor>
                <hashTree/>
                <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON断言" enabled="true">
                  <stringProp name="JSON_PATH">.code</stringProp>
                  <stringProp name="EXPECTED_VALUE">0</stringProp>
                  <boolProp name="JSONVALIDATION">true</boolProp>
                  <boolProp name="EXPECT_NULL">false</boolProp>
                  <boolProp name="INVERT">false</boolProp>
                  <boolProp name="ISREGEX">true</boolProp>
                </JSONPathAssertion>
                <hashTree/>
                <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="调试后置处理程序" enabled="true">
                  <boolProp name="displayJMeterProperties">false</boolProp>
                  <boolProp name="displayJMeterVariables">true</boolProp>
                  <boolProp name="displaySamplerProperties">true</boolProp>
                  <boolProp name="displaySystemProperties">false</boolProp>
                </DebugPostProcessor>
                <hashTree/>
              </hashTree>
            </hashTree>
          </hashTree>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="简单控制器" enabled="true"/>
          <hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="大小球" enabled="true">
              <stringProp name="HTTPSampler.path">/api/c/user/lottery/view</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <stringProp name="HTTPSampler.method">GET</stringProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="用户定义的变量">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="areaType" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.name">areaType</stringProp>
                    <stringProp name="Argument.value">2</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  </elementProp>
                  <elementProp name="ratioType" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.name">ratioType</stringProp>
                    <stringProp name="Argument.value">3</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="X-Timestamp" elementType="Header">
                    <stringProp name="Header.name">X-Timestamp</stringProp>
                    <stringProp name="Header.value">${X-Timestamp}</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 预处理程序" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import java.security.KeyFactory
import java.security.PrivateKey
import java.security.Signature
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Base64
import java.util.TreeMap
import java.util.stream.Collectors

// 定义常量
def talentId = vars.get(&quot;X-Tenant-Id&quot;)
def timestamp = System.currentTimeMillis().toString()
//def timestamp = vars.get(&quot;login-Timestamp&quot;)
def deviceId = vars.get(&quot;X-Device-Id&quot;)
def token = vars.get(&quot;X-Token&quot;)
//def token = vars.get(&quot;token_&quot; + ctx.getThreadNum()) // 使用 ctx.getThreadNum() 获取线程编号
def appVersion = vars.get(&quot;X-App-Version&quot;)
def traceId = vars.get(&quot;X-Trace-Id&quot;)
def salt = vars.get(&quot;salt&quot;)

// 创建 TreeMap 并添加参数
def headers = new TreeMap&lt;String, String&gt;()
headers.put(&quot;X-Tenant-Id&quot;, talentId)
headers.put(&quot;X-Timestamp&quot;, timestamp)
headers.put(&quot;X-Device-Id&quot;, deviceId)
headers.put(&quot;X-Token&quot;, token)
headers.put(&quot;X-App-Version&quot;, appVersion)
headers.put(&quot;X-Trace-Id&quot;, traceId)

// 生成数据字符串
def data = headers.entrySet()
    .stream()
    .map { entry -&gt; entry.getKey() + &quot;=&quot; + entry.getValue() }
    .collect(Collectors.joining(&quot;&amp;&quot;))

// 签名生成方法
def sign(String data, String salt, PrivateKey key) {
    def signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initSign(key)
    data = data + salt
    signature.update(data.getBytes())
    return new String(Base64.getEncoder().encode(signature.sign()))
}

// Base64 编码的私钥字符串
String base64PrivateKey = &quot;${PrivateKey}&quot;

// 解码 Base64 字符串为字节数组
byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey)

// 使用 KeyFactory 生成 PrivateKey 对象
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
PrivateKey key = keyFactory.generatePrivate(keySpec)

// 生成签名
def signature = sign(data, salt, key)

// 将签名存储到 JMeter 变量中
vars.put(&quot;X-Timestamp&quot;, timestamp)
vars.put(&quot;srcData&quot;, data)
vars.put(&quot;X-Sign&quot;, signature)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;sign_&quot; + ctx.getThreadNum(), signature)

// 设置全局变量（如果需要）
//props.put(&quot;X-Sign&quot;, signature)
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PreProcessor>
              <hashTree/>
              <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON断言" enabled="true">
                <stringProp name="JSON_PATH">.code</stringProp>
                <stringProp name="EXPECTED_VALUE">0</stringProp>
                <boolProp name="JSONVALIDATION">true</boolProp>
                <boolProp name="EXPECT_NULL">false</boolProp>
                <boolProp name="INVERT">false</boolProp>
                <boolProp name="ISREGEX">true</boolProp>
              </JSONPathAssertion>
              <hashTree/>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON提取器" enabled="true">
                <stringProp name="JSONPostProcessor.referenceNames">lottery;areaType</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">.data[-1].allLottery[*];.data[-1].areaType</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers">0</stringProp>
                <stringProp name="JSONPostProcessor.defaultValues">error;error</stringProp>
                <boolProp name="JSONPostProcessor.compute_concat">true</boolProp>
              </JSONPostProcessor>
              <hashTree/>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON提取器" enabled="true">
                <stringProp name="JSONPostProcessor.referenceNames">matchId;shortComp;shortHome;shortAway</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">.matchId;.shortComp;.shortHome;.shortAway</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers">1;1;1;1</stringProp>
                <stringProp name="JSONPostProcessor.defaultValues">error;error;error;error</stringProp>
                <boolProp name="JSONPostProcessor.compute_concat">true</boolProp>
                <stringProp name="Sample.scope">variable</stringProp>
                <stringProp name="Scope.variable">lottery</stringProp>
              </JSONPostProcessor>
              <hashTree/>
              <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="调试后置处理程序" enabled="true">
                <boolProp name="displayJMeterProperties">false</boolProp>
                <boolProp name="displayJMeterVariables">true</boolProp>
                <boolProp name="displaySamplerProperties">true</boolProp>
                <boolProp name="displaySystemProperties">false</boolProp>
              </DebugPostProcessor>
              <hashTree/>
              <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="JSR223 后置处理程序" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import groovy.json.JsonSlurper
import groovy.json.JsonOutput
import groovy.json.JsonGenerator

// 示例 JSON 数据
def jsonVar = vars.get(&quot;lottery&quot;)

// 去除不必要的反斜杠
def json01 = jsonVar.replaceAll(&quot;\\\\&quot;, &quot;&quot;)

// 解析 JSON 数据
def jsonSlurper = new JsonSlurper()
def data = jsonSlurper.parseText(json01)

// 将 JSON 中的 null 转换为 &quot;&quot;
def replaceNullWithEmptyString(obj) {
    if (obj instanceof Map) {
        obj.each { key, value -&gt; obj[key] = replaceNullWithEmptyString(value) }
    } else if (obj instanceof List) {
        obj.eachWithIndex { item, index -&gt; obj[index] = replaceNullWithEmptyString(item) }
    } else {
        return obj == null ? &quot;&quot; : obj
    }
    return obj
}

// 替换 null 值
data = replaceNullWithEmptyString(data)

// 初始化变量
def minValue = Float.MAX_VALUE
def minValueSource = &quot;&quot;
def lotType = 0 // 声明 lotType 变量

// 遍历 items，找到最小值及其来源
data.items.each { item -&gt;
    [&quot;valuex&quot;, &quot;valuey&quot;].each { key -&gt;
        def value = item[key].toFloat()
        if (value &lt; minValue) {
            minValue = value
            minValueSource = key
        }
    }
}

// 根据最小值的来源设置 selectRow 和 selectCol
if (minValueSource == &quot;valuex&quot;) {
    data.selectRow = &quot;items.spf&quot;
    data.selectCol = &quot;3&quot;
} else if (minValueSource == &quot;valuey&quot;) {
    data.selectRow = &quot;items.spf&quot;
    data.selectCol = &quot;0&quot;
}

// 输出新的 JSON 数据
def jsonGenerator = new JsonGenerator.Options()
    .disableUnicodeEscaping() // 禁用 Unicode 转义
    .build()

def newJson = jsonGenerator.toJson(data)

// 添加反斜杠转义
def escapedJson = newJson.replaceAll(/&quot;/, &quot;\\\\\&quot;&quot;)

vars.put(&quot;planDetails&quot;, escapedJson) // 将新 JSON 存储为 JMeter 变量
log.info(&quot;新 JSON 数据: &quot; + escapedJson)
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PostProcessor>
              <hashTree/>
            </hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="发布条件校验" enabled="true">
              <stringProp name="HTTPSampler.path">/api/c/user/plan/match/validate</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">{&quot;matchIds&quot;:&quot;${matchId}&quot;,&quot;lotType&quot;:&quot;${lotType}&quot;,&quot;areaType&quot;:&quot;${areaType}&quot;}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="X-Timestamp" elementType="Header">
                    <stringProp name="Header.name">X-Timestamp</stringProp>
                    <stringProp name="Header.value">${X-Timestamp}</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 预处理程序" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import java.security.KeyFactory
import java.security.PrivateKey
import java.security.Signature
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Base64
import java.util.TreeMap
import java.util.stream.Collectors

// 定义常量
def talentId = vars.get(&quot;X-Tenant-Id&quot;)
def timestamp = System.currentTimeMillis().toString()
//def timestamp = vars.get(&quot;login-Timestamp&quot;)
def deviceId = vars.get(&quot;X-Device-Id&quot;)
def token = vars.get(&quot;X-Token&quot;)
//def token = vars.get(&quot;token_&quot; + ctx.getThreadNum()) // 使用 ctx.getThreadNum() 获取线程编号
def appVersion = vars.get(&quot;X-App-Version&quot;)
def traceId = vars.get(&quot;X-Trace-Id&quot;)
def salt = vars.get(&quot;salt&quot;)

// 创建 TreeMap 并添加参数
def headers = new TreeMap&lt;String, String&gt;()
headers.put(&quot;X-Tenant-Id&quot;, talentId)
headers.put(&quot;X-Timestamp&quot;, timestamp)
headers.put(&quot;X-Device-Id&quot;, deviceId)
headers.put(&quot;X-Token&quot;, token)
headers.put(&quot;X-App-Version&quot;, appVersion)
headers.put(&quot;X-Trace-Id&quot;, traceId)

// 生成数据字符串
def data = headers.entrySet()
    .stream()
    .map { entry -&gt; entry.getKey() + &quot;=&quot; + entry.getValue() }
    .collect(Collectors.joining(&quot;&amp;&quot;))

// 签名生成方法
def sign(String data, String salt, PrivateKey key) {
    def signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initSign(key)
    data = data + salt
    signature.update(data.getBytes())
    return new String(Base64.getEncoder().encode(signature.sign()))
}

// Base64 编码的私钥字符串
String base64PrivateKey = &quot;${PrivateKey}&quot;

// 解码 Base64 字符串为字节数组
byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey)

// 使用 KeyFactory 生成 PrivateKey 对象
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
PrivateKey key = keyFactory.generatePrivate(keySpec)

// 生成签名
def signature = sign(data, salt, key)

// 将签名存储到 JMeter 变量中
vars.put(&quot;X-Timestamp&quot;, timestamp)
vars.put(&quot;srcData&quot;, data)
vars.put(&quot;X-Sign&quot;, signature)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;sign_&quot; + ctx.getThreadNum(), signature)

// 设置全局变量（如果需要）
//props.put(&quot;X-Sign&quot;, signature)
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PreProcessor>
              <hashTree/>
              <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON断言" enabled="true">
                <stringProp name="JSON_PATH">.code</stringProp>
                <stringProp name="EXPECTED_VALUE">0</stringProp>
                <boolProp name="JSONVALIDATION">true</boolProp>
                <boolProp name="EXPECT_NULL">false</boolProp>
                <boolProp name="INVERT">false</boolProp>
                <boolProp name="ISREGEX">true</boolProp>
              </JSONPathAssertion>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="IF 控制器" enabled="true">
              <stringProp name="IfController.condition">${JMeterThread.last_sample_ok}</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
              <boolProp name="IfController.useExpression">true</boolProp>
            </IfController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="大小球-发布方案" enabled="true">
                <stringProp name="HTTPSampler.path">/api/c/user/plan/publish</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">{&#xd;
	&quot;recommendTitle&quot;: &quot;[${shortComp}]100命中率继续带来稳单分享,胜平负总进球方向都很准。${Price}鲸&quot;,&#xd;
	&quot;planWays&quot;: 1,&#xd;
	&quot;matchIds&quot;: &quot;${matchId}&quot;,&#xd;
	&quot;planDetailIds&quot;: &quot;${planDetailIds}&quot;,&#xd;
	&quot;lotClass&quot;: 11,&#xd;
	&quot;isFree&quot;: ${isFree},&#xd;
	&quot;planDetails&quot;:&quot;[${planDetails}]&quot;,&#xd;
	&quot;lotType&quot;: &quot;3&quot;,&#xd;
	&quot;discountPrice&quot;: ${Price},&#xd;
	&quot;areaType&quot;: &quot;${areaType}&quot;,&#xd;
	&quot;sportType&quot;: &quot;1&quot;,&#xd;
	&quot;recommendContent&quot;: &quot;本方案中的${shortComp}赛事(${matchId})主队${shortHome}近期状态不错,${shortAway}也实力不俗。\n除了结合指数和${shortHome}、${shortAway}历史交锋数据，还有很重要的是能分清楚烟雾弹，排除机构给出来的陷阱，因此也考验一个人的能力。多看多总结，总能找到属于你自己的规律。\n本场胜负方向，${shortAway}不败。本场进球总数方向，2球以上&quot;&#xd;
}&#xd;
</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <GaussianRandomTimer guiclass="GaussianRandomTimerGui" testclass="GaussianRandomTimer" testname="高斯随机定时器" enabled="true">
                  <stringProp name="ConstantTimer.delay">101000</stringProp>
                  <stringProp name="RandomTimer.range">51000</stringProp>
                </GaussianRandomTimer>
                <hashTree/>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="X-Timestamp" elementType="Header">
                      <stringProp name="Header.name">X-Timestamp</stringProp>
                      <stringProp name="Header.value">${X-Timestamp}</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
                <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 预处理程序" enabled="true">
                  <stringProp name="cacheKey">true</stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="script">import java.security.KeyFactory
import java.security.PrivateKey
import java.security.Signature
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Base64
import java.util.TreeMap
import java.util.stream.Collectors

// 定义常量
def talentId = vars.get(&quot;X-Tenant-Id&quot;)
def timestamp = System.currentTimeMillis().toString()
//def timestamp = vars.get(&quot;login-Timestamp&quot;)
def deviceId = vars.get(&quot;X-Device-Id&quot;)
def token = vars.get(&quot;X-Token&quot;)
//def token = vars.get(&quot;token_&quot; + ctx.getThreadNum()) // 使用 ctx.getThreadNum() 获取线程编号
def appVersion = vars.get(&quot;X-App-Version&quot;)
def traceId = vars.get(&quot;X-Trace-Id&quot;)
def salt = vars.get(&quot;salt&quot;)

// 创建 TreeMap 并添加参数
def headers = new TreeMap&lt;String, String&gt;()
headers.put(&quot;X-Tenant-Id&quot;, talentId)
headers.put(&quot;X-Timestamp&quot;, timestamp)
headers.put(&quot;X-Device-Id&quot;, deviceId)
headers.put(&quot;X-Token&quot;, token)
headers.put(&quot;X-App-Version&quot;, appVersion)
headers.put(&quot;X-Trace-Id&quot;, traceId)

// 生成数据字符串
def data = headers.entrySet()
    .stream()
    .map { entry -&gt; entry.getKey() + &quot;=&quot; + entry.getValue() }
    .collect(Collectors.joining(&quot;&amp;&quot;))

// 签名生成方法
def sign(String data, String salt, PrivateKey key) {
    def signature = Signature.getInstance(&quot;SHA256WithRSA&quot;)
    signature.initSign(key)
    data = data + salt
    signature.update(data.getBytes())
    return new String(Base64.getEncoder().encode(signature.sign()))
}

// Base64 编码的私钥字符串
String base64PrivateKey = &quot;${PrivateKey}&quot;

// 解码 Base64 字符串为字节数组
byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey)

// 使用 KeyFactory 生成 PrivateKey 对象
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes)
KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;)
PrivateKey key = keyFactory.generatePrivate(keySpec)

// 生成签名
def signature = sign(data, salt, key)

// 将签名存储到 JMeter 变量中
vars.put(&quot;X-Timestamp&quot;, timestamp)
vars.put(&quot;srcData&quot;, data)
vars.put(&quot;X-Sign&quot;, signature)
// 将 token 保存到以 threadNum 为后缀的变量中
//vars.put(&quot;sign_&quot; + ctx.getThreadNum(), signature)

// 设置全局变量（如果需要）
//props.put(&quot;X-Sign&quot;, signature)
</stringProp>
                  <stringProp name="scriptLanguage">groovy</stringProp>
                </JSR223PreProcessor>
                <hashTree/>
                <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON断言" enabled="true">
                  <stringProp name="JSON_PATH">.code</stringProp>
                  <stringProp name="EXPECTED_VALUE">0</stringProp>
                  <boolProp name="JSONVALIDATION">true</boolProp>
                  <boolProp name="EXPECT_NULL">false</boolProp>
                  <boolProp name="INVERT">false</boolProp>
                  <boolProp name="ISREGEX">true</boolProp>
                </JSONPathAssertion>
                <hashTree/>
                <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="调试后置处理程序" enabled="true">
                  <boolProp name="displayJMeterProperties">false</boolProp>
                  <boolProp name="displayJMeterVariables">true</boolProp>
                  <boolProp name="displaySamplerProperties">true</boolProp>
                  <boolProp name="displaySystemProperties">false</boolProp>
                </DebugPostProcessor>
                <hashTree/>
              </hashTree>
            </hashTree>
          </hashTree>
        </hashTree>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
